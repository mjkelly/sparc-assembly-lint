/*
$Log: symtable.c,v $
Revision 1.10  1997/03/21 07:41:33  bediger
mark all symbols that still have n_type of N_UNDF, N_EXT

Revision 1.9  1997/03/14 05:37:33  bediger
make code reflect changes to struct expr_node (minimize size of that struct)

Revision 1.8  1997/02/27 07:40:47  bediger
correct SunOS-style local labels

Revision 1.7  1997/02/14 06:34:12  bediger
fix a memory leak: 0-length strings, generated by .stabd and .stabn
directives weeren't ever freed.

Revision 1.6  1997/01/05 08:51:31  bediger
remove unused variable, fix bugs relating to BSS segment symbols,
use convenience macros like SYMBOL_TYPE(), IS_SYMBOL_TYPE()

Revision 1.5  1996/12/29 01:18:06  bediger
support for cmd-line specification of symbol table debugging

Revision 1.4  1996/12/19 06:50:25  bediger
added code to deal with SunOS assembler style "local labels"

Revision 1.3  1996/12/17 06:31:02  bediger
minor changes to reflect new operations that may appear in expression
parse trees.

Revision 1.2  1996/12/14 20:00:37  bediger
removed functions based on lcc's "basic block" coverage results

Revision 1.1  1996/12/13 14:32:52  bediger
Initial revision

*/
static char rcsident[] = "$Header: /home/ediger/src/csrc/sparc_assembler10/RCS/symtable.c,v 1.10 1997/03/21 07:41:33 bediger Exp bediger $";

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <errno.h>
#include <a.out.h>
#include <nlist.h>
#include <ctype.h>  /* isdigit() */

#include <assy.h>
#include <io.h>
#include <expr.h>
#include <symtable.h>
#include <hashtable.h>
#include <digit_label.h>

#ifdef USE_DMALLOC
#include <dmalloc.h>
#endif


struct hashtable *symtable = NULL;
int symtable_transformed = 0;

struct relocation_info *new_relocation(void);

struct relocations *tr = NULL;
struct relocations *dr = NULL;

void real_insert_relocation(struct relocations *tbl, struct relocation_info *reloc, struct nlist *symbol);
unsigned long write_relocations(struct relocations *rl, FILE *a_out);

/* caller must manage the memory pointed to by expr argument */
struct nlist *
assemble_label(struct expr_node *expr)
{
	struct nlist *p;

	assert(NULL != expr);

	switch (expr->kind)
	{
	case ExprCon:
		if (NULL == (p = local_symbol_named(expr->u.val)))
		{
			p = assemble_digit_label(expr->u.val);
			p->n_value = N_UNDF;
			p->n_type = N_UNDF;
		} else
			passed_local(expr->u.val);
		break;
	case ExprSym:
		if (NULL == (p = symbol_lookup(symtable, expr->u.id)))
		{
			p = add_symbol_named(expr->u.id);
			p->n_value = N_UNDF;
			p->n_type = N_UNDF;
		}
		break;
	default:
		internal_problem(__FILE__, __LINE__, "assemble_label(), expr: ");
		print_expr(stderr, expr);
		putc('\n', stderr);
		p = NULL;
		break;
	}

	return p;
}

/* walk the list of relocations passed in, write unresolved stuff
 * to FILE *a_out, free stuff pointed to */
unsigned long
write_relocations(struct relocations *rl, FILE *a_out)
{
	int i;
	unsigned long size = 0;

	for (i = 0; i < rl->used; ++i)
	{
		struct hashnode *hn;

		hn = node_lookup(symtable, rl->data[i].sym->n_un.n_name);
		if (NULL != hn && 'L' != *rl->data[i].sym->n_un.n_name &&
			rl->data[i].reloc->r_extern)
		{
			/* essentially, the r_extern bit is set */
			rl->data[i].reloc->r_symbolnum = hn->ordinal;
		} else {
			rl->data[i].reloc->r_symbolnum = SYMBOL_TYPE(rl->data[i].sym);
			rl->data[i].reloc->r_addend += rl->data[i].sym->n_value;
				
		}

		if (sym_debug)
			fprintf(stderr, "Writing relocation at 0x%x, addend %d, %s, points to symbol named \"%s\" (ord %d)\n",
				rl->data[i].reloc->r_address, 
				rl->data[i].reloc->r_addend, 
				rl->data[i].reloc->r_extern? "extern" : "local",
				rl->data[i].sym->n_un.n_name,  rl->data[i].reloc->r_symbolnum);

		if (fwrite((void *)rl->data[i].reloc, sizeof(struct relocation_info), 1, a_out) != 1)
		{
			internal_problem(__FILE__, __LINE__, "Trouble writing text relocation %d of %d: %s\n",
				i, rl->used, strerror(errno));
		} else
			size += sizeof(struct relocation_info);

		free(rl->data[i].reloc);
	}

	if (NULL != rl)
	{
		if (NULL != rl->data)
			free(rl->data);
		free(rl);
	}
	
	return size;
}

unsigned long
write_text_relocations(FILE *a_out)
{
	if (offset_debug)
		fprintf(stderr, "offset: writing text relocations beginning at %d\n",
			ftell(a_out));
	return write_relocations(tr, a_out);
}

unsigned long
write_data_relocations(FILE *a_out)
{
	if (offset_debug)
		fprintf(stderr, "offset: writing data relocations beginning at %d\n",
			ftell(a_out));
	return write_relocations(dr, a_out);
}

void
insert_relocation(char *file, int linenum, struct relocation_info *reloc, struct nlist *symbol)
{
	reloc->r_extern = (IS_SYMBOL_TYPE(symbol, N_UNDF))? 1: 0;

	if (sym_debug)
	{
		fprintf(stderr,
			"adding relocation at 0x%x, in %s segment, %s, type %s," " points to symbol named \"%s\" at 0x%x, type %s, %s, %d\n",
			reloc->r_address,
			((TEXT_SEG == current_segment)? "TEXT" : "DATA"),
			(reloc->r_extern ? "external" : "local"),
			print_reloc_type(reloc->r_type),
			symbol->n_un.n_name,
			symbol->n_value,
			print_n_type(symbol->n_type), file, linenum
		);
	}

	if (TEXT_SEG == current_segment)
		real_insert_relocation(tr, reloc, symbol);
	else
		real_insert_relocation(dr, reloc, symbol);
}

void
real_insert_relocation(struct relocations *tbl, struct relocation_info *reloc, struct nlist *symbol)
{
	
	assert(NULL != tbl);

	if (tbl->used >= tbl->size)
	{
		tbl->size += 5;  /* again, totally arbitrary */

		tbl->data = ((NULL != tbl->data)?
			realloc(tbl->data, tbl->size*sizeof(*tbl->data)) :
			malloc(tbl->size*sizeof(*tbl->data)));

		assert(NULL != tbl->data);
	}

	tbl->data[tbl->used].reloc = reloc;
	tbl->data[tbl->used].sym = symbol;

	++tbl->used;
}

void
enumerate_symbols(int weedout_locals)
{
	struct hashnode *p; 
	int ordinal = 0;

	p = symtable->head->ord_next;

	while (symtable->tail != p)
	{
		if (weedout_locals && 'L' == p->symbol->n_un.n_name[0])
			p->ordinal = -1;
		else {
			p->ordinal = ordinal++;

			if (sym_debug)
			{
				fprintf(stderr, "enumerating symbol named \"%s\" as symbol ordinal %d\n",
					p->symbol->n_un.n_name, p->ordinal);
			}
		}

		p = p->ord_next;
	}
}

struct stringtable *
create_stringtable(int weedout_locals)
{
	int r_used = 1;
	int r_size = 1;
	struct hashnode *p; 
	struct stringtable *strtable;

	if (symtable_transformed)
	{
		internal_problem(__FILE__, __LINE__, "trying to create a stringtable for at least the 2nd time\n");
		return NULL;
	}

	STRUCT_ALLOC(strtable, struct stringtable);

	/* prime it with a zero-length string */
	strtable->data = malloc(1);
	strtable->data[0] = '\0';

	symtable_transformed = 1;

	p = symtable->head->ord_next;

	while (symtable->tail != p)
	{
		if (weedout_locals && -1 != p->ordinal)
		{
			int l = strlen(p->symbol->n_un.n_name);

			if (l > 0)
			{
				if ((r_used + l + 1) >= r_size)
				{
					r_size += (l + 33);  /* 32 is totally arbitrary */
					strtable->data = realloc(strtable->data, r_size);
					assert(NULL != strtable->data);
				}

				strcpy(&strtable->data[r_used], p->symbol->n_un.n_name);
				free(p->symbol->n_un.n_name);
				/* n_un.n_name pointer gets smashed */
				p->symbol->n_un.n_strx = r_used + sizeof(strtable->length);
				r_used += l + 1;
			} else {
				free(p->symbol->n_un.n_name);
				/* the frequent case of zero-length symbol name */
				p->symbol->n_un.n_strx = 0;
			}

		} else {
			free(p->symbol->n_un.n_name);
			p->symbol->n_un.n_name = NULL;
		}

		p = p->ord_next;
	}

	strtable->length = r_used + sizeof(strtable->length);
	assert(4 <= strtable->length);

	return strtable;
}

void
free_symtable()
{
	if (NULL != symtable)
	{
		free_hashtable(symtable);
		free(symtable);
	}
}

struct nlist *
symbol_named(char *sym_name)
{
	if (isdigit(*sym_name))
		return lookup_digit(sym_name);

	return symbol_lookup(symtable, sym_name);
}

struct nlist pass1_dummy;

/* sym_name argument gets strdup'ed: caller must manage the sym_name
 * memory. */
struct nlist *
add_symbol_named(char *sym_name)
{
	struct nlist *sym;

	if (isdigit(*sym_name))
		return lookup_digit(sym_name);

	STRUCT_ALLOC(sym, struct nlist);

	assert(NULL != (sym->n_un.n_name = strdup(sym_name)));

	sym->n_type = N_UNDF;
	sym->n_desc = N_UNDF;
	sym->n_other = 0;
	sym->n_value = 0L;

	add_symbol(symtable, sym);

	return sym;
}

void
add_stab(struct nlist *nl)
{
	add_unhashed_symbol(symtable, nl);
}

void
adjust_segment(int segment, int offset)
{
	struct hashnode *p; 

	p = symtable->head->ord_next;

	while (symtable->tail != p)
	{
		if (IS_SYMBOL_TYPE(p->symbol, segment))
			p->symbol->n_value += offset;

		p = p->ord_next;
	}
}

unsigned long
write_symtable(FILE *a_out, struct stringtable *strtbl)
{
	struct hashnode *p; 
	unsigned long size = 0;

	assert(NULL != a_out);
	assert(NULL != strtbl);

	if (offset_debug)
		fprintf(stderr, "offset: writing symbol table beginning at %d\n",
			ftell(a_out));

	p = symtable->head->ord_next;

	while (symtable->tail != p)
	{
		if (-1 != p->ordinal)
		{
			if (sym_debug)
			{
				fprintf(stderr, "Writing symbol, ordinal %d, name \"%s\" "
					"(index %d), value 0x%x, type %s\n",
					p->ordinal,
					&strtbl->data[p->symbol->n_un.n_strx - 4],
					p->symbol->n_un.n_strx,
					p->symbol->n_value,
					print_n_type(p->symbol->n_type)
				);
			}

			if (N_UNDF == (p->symbol->n_type & N_TYPE) && !(p->symbol->n_type & N_STAB))
			{	/* it has to be an external symbol if it's still undefined */
				if (sym_debug)
				{
					fprintf(stderr,
						"symbol name \"%s\", type is N_UNDF, marking as N_EXT\n",
						&strtbl->data[p->symbol->n_un.n_strx - 4]);
				}
				p->symbol->n_type |= N_EXT;
			}

			if (fwrite((void *)p->symbol, sizeof(struct nlist), 1, a_out) != 1)
			{
				internal_problem(__FILE__, __LINE__,
					"trouble writing struct nlist to output file: %s\n",
					strerror(errno));
				break;
			}

			size += sizeof(struct nlist);
		}

		p = p->ord_next;
	}

	return size;
}

void
init_symtable()
{
	STRUCT_ALLOC(symtable, struct hashtable);
	init_hashtable(symtable, 8, 5);
}

void
init_relocation()
{
	STRUCT_ALLOC(tr, struct relocations);
	STRUCT_ALLOC(dr, struct relocations);

	tr->used = tr->size = 0;
	dr->used = dr->size = 0;

	tr->data = dr->data = NULL;
}

/* F+ void print_n_type()
 *
 * print out relocation type per /usr/include/machine/stab.h 
 *
 *F-*/
char print_n_type_buffer[256];
char *
print_n_type(char ntype)
{
	*print_n_type_buffer = '\0';

	if (ntype & N_EXT)
		strcpy(print_n_type_buffer, "N_EXT|");

	switch ((ntype & N_TYPE) & (~N_EXT))
	{
	case N_UNDF:
		strcat(print_n_type_buffer, "N_UNDF");
		break;
	case N_ABS:
		strcat(print_n_type_buffer, "N_ABS");
		break;
	case N_TEXT:
		strcat(print_n_type_buffer, "N_TEXT");
		break;
	case N_DATA:
		strcat(print_n_type_buffer, "N_DATA");
		break;
	case N_BSS:
		strcat(print_n_type_buffer, "N_BSS");
		break;
	case N_COMM:
		strcat(print_n_type_buffer, "N_COMM");
		break;
	case N_FN:
		strcat(print_n_type_buffer, "N_FN");
		break;
	default:
		strcat(print_n_type_buffer, "unknown");
		break;
	}

	if (ntype & N_STAB)
		strcat(print_n_type_buffer, ", SDB entry");

	return print_n_type_buffer;
}

char *
print_reloc_type(enum reloc_type type)
{
	char *r = NULL;

	if (type == RELOC_8) {
		r = "RELOC_8";
	} else if (type == RELOC_16) {
		r = "RELOC_16";
	} else if (type == RELOC_32) {
		r = "RELOC_32";
	} else if (type == RELOC_DISP8) {
		r = "RELOC_DISP8";
	} else if (type == RELOC_DISP16) {
		r = "RELOC_DISP16";
	} else if (type == RELOC_DISP32) {
		r = "RELOC_DISP32";
	} else if (type == RELOC_WDISP30) {
		r = "RELOC_WDISP30";
	} else if (type == RELOC_WDISP22) {
		r = "RELOC_WDISP22";
	} else if (type == RELOC_HI22) {
		r = "RELOC_HI22";
	} else if (type == RELOC_22) {
		r = "RELOC_22";
	} else if (type == RELOC_13) {
		r = "RELOC_13";
	} else if (type == RELOC_LO10) {
		r = "RELOC_LO10";
	} else if (type == RELOC_BASE13) {
		r = "RELOC_BASE13";
	} else if (type == RELOC_BASE22) {
		r = "RELOC_BASE22";
	} else if (type == RELOC_PC10) {
		r = "10 bit PC relative PIC";
	} else if (type == RELOC_PC22) {
		r = "22 bit PC relative PIC";
	} else if (type == RELOC_JMP_TBL) {
		r = "jump table relative PIC";
	} else if (type == RELOC_GLOB_DAT) {
		r = "rtld global data";
	} else if (type == RELOC_JMP_SLOT) {
		r = "rtld jump slot";
	} else if (type == RELOC_RELATIVE) {
		r = "rtld relative";
	} else {
		r = "some unknown reloc type...";
	}

	assert(NULL != r);

	return r;
}
